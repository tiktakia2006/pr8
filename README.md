# ПРАКТИЧНА РОБОТА 8

## ЗАВДАННЯ 1

## Умова
Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

## Код до завдання
```
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

int main() {
    int pipefd[2];
    char buffer[10000];
    memset(buffer, 'a', sizeof(buffer));

    if (pipe(pipefd) == -1) return 1;

    int flags = fcntl(pipefd[1], F_GETFL);
    fcntl(pipefd[1], F_SETFL, flags | O_NONBLOCK);

    while (1) {
        ssize_t count = write(pipefd[1], buffer, sizeof(buffer));
        if (count == -1) break;
        printf("записано байтів: %zd\n", count);
        if (count < sizeof(buffer)) {
            printf("частковий запис\n");
            break;
        }
    }

    close(pipefd[0]);
    close(pipefd[1]);
    return 0;
}


```

## Опис програми
так, виклик count = write(fd, buffer, nbytes); може повернути значення, відмінне від nbytes. це трапляється, коли дескриптор файлу працює в неблокуючому режимі, або коли системний буфер для запису частково заповнений. у наведеному прикладі створюється неблокуючий канал (pipe) і в нього багаторазово записуються дані розміром 10000 байтів. у циклі видно, що деякі виклики write() повертають повний розмір, а на певному етапі - менший (наприклад, 4096 байтів). це свідчить про частковий запис, який відбувся через заповнення буфера каналу. вивід програми підтверджує, що write() успішно завершився, але записав не всі байти. отже, функція write() не гарантує повний запис, і це нормальна поведінка. тому програміст має обробляти такі ситуації вручну, наприклад, у циклі

## Результати програми
![image](https://github.com/user-attachments/assets/e2cd35d0-4cca-4db6-a558-5193b4a6ef0a)


## ЗАВДАННЯ 2

## Умова
Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь

## Код до завдання
```
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("test.bin", O_RDONLY);
    unsigned char buffer[4];

    lseek(fd, 3, SEEK_SET);
    read(fd, buffer, 4);

    for (int i = 0; i < 4; i++)
        printf("%d ", buffer[i]);

    printf("\n");
    close(fd);
    return 0;
}

```

## Опис програми
програма відкриває файл test.bin, який містить 10 байтів. виклик lseek(fd, 3, SEEK_SET) переміщує покажчик на байт з індексом 3 (тобто на четвертий байт). далі read(fd, buffer, 4) читає 4 байти, починаючи з цього місця. отже, в буфер потрапляють байти з індексами 3, 4, 5, 6 - це значення 2, 3, 3, 7. вивід програми підтверджує це, оскільки виводить саме ці чотири числа. таким чином, буфер міститиме: 2, 3, 3, 7
## Результати програми
![image](https://github.com/user-attachments/assets/68e2f0c5-3573-4838-a9d3-c2bad49b614d)


## ЗАВДАННЯ 3
## Умова
Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
 Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

int cmp(const void *a, const void *b) {
    int ia = *(int *)a;
    int ib = *(int *)b;
    return ia - ib;
}

int is_sorted(int *arr, int size) {
    for (int i = 1; i < size; i++) {
        if (arr[i - 1] > arr[i]) return 0;
    }
    return 1;
}

void generate_sorted(int *arr, int size) {
    for (int i = 0; i < size; i++)
        arr[i] = i;
}

void generate_reversed(int *arr, int size) {
    for (int i = 0; i < size; i++)
        arr[i] = size - i;
}

void generate_equal(int *arr, int size) {
    for (int i = 0; i < size; i++)
        arr[i] = 42;
}

void generate_random(int *arr, int size) {
    for (int i = 0; i < size; i++)
        arr[i] = rand() % size;
}

void benchmark(const char *label, void (*gen)(int *, int), int size) {
    int *arr = malloc(size * sizeof(int));
    gen(arr, size);

    clock_t start = clock();
    qsort(arr, size, sizeof(int), cmp);
    clock_t end = clock();

    printf("%s: %ld мс, правильність: %s\n", label,
           (end - start) * 1000 / CLOCKS_PER_SEC,
           is_sorted(arr, size) ? "так" : "ні");

    free(arr);
}

int main() {
    srand(time(NULL));
    int size = 100000;

    benchmark("відсортований", generate_sorted, size);
    benchmark("у зворотному порядку", generate_reversed, size);
    benchmark("однакові елементи", generate_equal, size);
    benchmark("випадковий", generate_random, size);

    return 0;
}


```

## Опис програми
цей код використовує бібліотечну функцію `qsort` для сортування масивів різних типів вхідних даних. програма перевіряє, як швидко `qsort` працює з різними типами масивів: відсортованими, зворотними, масивами з однаковими елементами та випадковими даними. для кожного типу даних виконується функція `benchmark`, яка генерує масив певного типу, сортує його за допомогою `qsort` і вимірює час сортування.
функція `cmp` - це функція порівняння для `qsort`, яка порівнює два елементи масиву. вона визначає, чи один елемент більше чи менший за інший. функція `is_sorted` перевіряє, чи є масив відсортованим після сортування, порівнюючи кожен елемент з наступним.
для кожного тесту виводиться час, який знадобився для сортування, і чи був масив правильно відсортований. результат виведення, наприклад, "відсортований: 1 мс, правильність: так", показує, що сортування відсортованого масиву зайняло 1 мілісекунду, і воно було правильним. "у зворотному порядку: 2 мс, правильність: так" показує, що сортування зворотного масиву зайняло 2 мс і також було правильним.
кожен тип масиву впливає на ефективність `qsort`. для відсортованих масивів сортування відбувається дуже швидко, оскільки елементи вже відсортовані. для зворотного масиву і випадкових даних час може бути більшим, оскільки алгоритм має виконувати більше операцій для досягнення відсортованості. якщо масив складається з однакових елементів, сортування також відбувається дуже швидко, оскільки елементи не потребують змін.
ці тести демонструють, як ефективність швидкого сортування залежить від виду вхідних даних, а також підтверджують правильність роботи `qsort`, оскільки всі результати перевіряються за допомогою функції `is_sorted`

## Результати програми
![image](https://github.com/user-attachments/assets/6ad38200-247f-4562-9a9e-62ec2968aab1)


## ЗАВДАННЯ 4

## Умова
Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

## Код до завдання
```
#include <stdio.h>
#include <unistd.h>

int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
  return 0;
}


```

## Опис програми
програма використовує функцію `fork()`, яка створює новий процес, копіюючи батьківський процес. після виклику `fork()` обидва процеси (батьківський і дочірній) продовжують виконання програми. в батьківському процесі функція `fork()` повертає ідентифікатор дочірнього процесу (pid), а в дочірньому - 0. у результаті програма виводить два значення: для батьківського процесу - це pid дочірнього процесу (в нашому випадку 7433), а для дочірнього - 0. це означає, що батьківський процес отримує ідентифікатор дочірнього процесу, а дочірній процес отримує 0, що є типовим поведінком після виклику `fork()`
## Результати програми
![image](https://github.com/user-attachments/assets/a20ab2f3-5f55-4613-997d-ca4ce6116f27)


## ЗАВДАННЯ 5 (варіант 13)

## Умова
Побудуйте систему, яка перезаписує файл з одночасним використанням mmap() і write() та порівняйте результати.
## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

#define FILE_NAME "testfile.txt"
#define SIZE 1024

void write_using_write() {
    int fd = open(FILE_NAME, O_RDWR | O_CREAT | O_TRUNC, 0666);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    char buffer[SIZE];
    memset(buffer, 'A', SIZE);
    write(fd, buffer, SIZE);
    close(fd);
}

void write_using_mmap() {
    int fd = open(FILE_NAME, O_RDWR | O_CREAT | O_TRUNC, 0666);
    if (fd == -1) {
        perror("open");
        exit(1);
    }

    ftruncate(fd, SIZE);

    char *map = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (map == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }
    memset(map, 'B', SIZE);
    msync(map, SIZE, MS_SYNC);
    munmap(map, SIZE);
    close(fd);
}

int main() {
    write_using_write();
    printf("File written using write().\n");

    write_using_mmap();
    printf("File written using mmap().\n");

    return 0;
}



```

## Опис програми
я написав програму, яка порівнює два методи запису даних у файл: через функцію write() і через використання пам'яті за допомогою mmap(). спочатку я реалізував метод за допомогою write(), де відкриваю файл на запис, створюю масив, заповнений символами 'A', і записую цей масив у файл. після цього закриваю файл. потім я реалізував другий метод за допомогою mmap(). тут я спочатку відкриваю файл, збільшую його розмір за допомогою ftruncate(), потім відображаю файл в пам'ять за допомогою mmap(), змінюю вміст на символи 'B' і синхронізую зміни з файлом за допомогою msync(). після цього я закриваю файл. у результаті виконання програми на екран виводяться повідомлення, що файл був записаний спочатку через write(), а потім через mmap(). після виконання програми я перевірив вміст файлу: спочатку він містить символи 'A', а після використання mmap() - символи 'B'. це підтверджує, що кожен метод виконується правильно і замінює вміст файлу відповідно до своїх механізмів. таким чином, я порівняв два методи запису даних у файл, де кожен підхід використовує свої переваги в залежності від задачі.
## Результати програми
![image](https://github.com/user-attachments/assets/4f0a9267-daab-40f0-b597-d2f05965498b)
![image](https://github.com/user-attachments/assets/4b1b0331-b6b6-4e23-8f46-db4f1e5283a7)

